<link rel="import" href="../polymer/polymer.html">

<script>
  /**
   * Make the most of Polymer's [`<neon-animated-pages>`](https://github.com/PolymerElements/neon-animation#page-transitions) effortlessly.
   * NeonPageBehavior fires events allowing more control over a page's lifecycle,
   * and allows your page element to use a different animation-configuration when
   * transitioning to each different page.
   *
   * * [Page lifecycle](#lifecycle)
   * * [Declaring different animation configurations](#animation)
   *   * [animationConfig](#animation_config)
   *   * [sharedElements](#shared_elements)
   *
   * <a name="lifecycle"></a>
   * ## Page lifecycle 
   *
   * Elements having the `NeonPageBehavior` and being a child of a [`<neon-animated-pages>`](https://github.com/PolymerElements/neon-animation#page-transitions)
   * element can listen to 4 new events:
   * * `entry-animation-start`:
   *      Called BEFORE the transition TO the page starts.
   *      Useful to handle initialization before your page gets visible
   *      (start loading data, animation optimisation,...).
   *
   * * `entry-animation-finish`:
   *      Called AFTER the transition TO the page finished.
   *      Useful to finish initialization of your page (allow user focus,...).
   *
   * * `exit-animation-start`:
   *      Called BEFORE the transition FROM the page starts.
   *      Useful to deal with exit tasks (disallow user focus, animation optimisation,...).
   *
   * * `exit-animation-finish`:
   *      Called AFTER the transition FROM the page finished.
   *      Useful to handle exit tasks when your page isn't visible anymore
   *      (reset scroller position,...).
   *
   * The `detail` of the dispatched events contains the following properties :
   * * `animationConfig`:
   *      The `animationConfig` of the target page for the transition.
   * * `sharedElements`:
   *      The `sharedElements` of the target page for the transition.
   * * `from`:
   *      The identifier of the original page of the transition, as in
   *      `neon-animated-pages.selected`.
   * * `fromPage`:
   *      The reference to the original page of the transition.
   * * `to`:
   *      The identifier of the destination page of the transition, as in
   *      `neon-animated-pages.selected`.
   * * `toPage`:
   *      The reference to the destination page of the transition.
   *
   * 
   * <a name="animation"></a>
   * ## Declaring different animation  configurations
   *
   * <a name="animation_config"></a>
   * ### animationConfig
   * Elements having the `NeonPageBehavior` and being child of a [`<neon-animated-pages>`](https://github.com/PolymerElements/neon-animation#page-transitions)
   * can also declared different `animationConfig` properties that will be used
   * automatically for transitioning to and from each different page.
   *
   * These properties' names must respect the following naming convention:
   *
   * `animationConfig` + value representing the page to transition from/to for the parent `<neon-animated-pages>`
   * (see `selected` and `attrForSelected` properties in the
   * [`<neon-animated-pages>`](https://github.com/PolymerElements/neon-animation#page-transitions)
   * documentation for more detail on this), all normalized to become a valid javascript variable name.
   * (ie if `pageValue`='home-alone', the `animationConfigHomeAlone` property will be used if it is defined, and `animationConfig` if not).
   *
   * <a name="shared_elements"></a>
   * ### sharedElements
   * If your element also have the [`NeonSharedElementAnimatableBehavior`](https://elements.polymer-project.org/elements/neon-animation?active=Polymer.NeonSharedElementAnimatableBehavior), you can similarly
   * declare different `sharedElements` properties for each different page to transition
   * from/to. The naming convention is the following:
   * 
   * `sharedElements` + value representing the page to transition from/to, all normalized to become a valid javascript variable name.
   * (ie if `pageValue`='home-alone', the `sharedElementsHomeAlone` property will be used if it is defined, and `sharedElements` if not).
   * 
   * You can also differentiate the
   * `sharedElements` for the transition FROM a given page (entering this element)
   * from the `sharedElements` for the transition TO a given page (exiting this element)
   * by following this naming convention:
   * 
   * `sharedElements` + value representing the page to transition from/to + `Entry` or `Exit`, all normalized to become a valid javascript variable name.
   * (ie if `pageValue`='home-alone' and entering this page from the page 'home-alone', the `sharedElementsHomeAloneEntry` property will be used if it is defined, `sharedElementsHomeAlone` otherwise and `sharedElements` if none of the 2 aforementioned properties are defined).
   * 
   * @blurb Make the most of Polymer's 'neon-animated-pages' effortlessly. NeonPageBehavior fires events allowing more control over a page's lifecycle, and allows your page element to use a different animation-configuration when transitioning to each different page.
   * @homepage https://github.com/vguillou/neon-page-behavior
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.NeonPageBehavior = {

    /**
     * Fired BEFORE the transition TO the page starts.
     * Useful to handle initialization before your page gets visible
     * (start loading data, animation optimisation,...).
     *
     * However it is not recommended to launch heavy processing at this
     * time not to hinder the transition's animation.
     *
     * @event entry-animation-start
     */

    /**
     * Fired AFTER the transition TO the page finished.
     * Useful to finish initialization of your page (allow user focus,...)
     *
     * @event entry-animation-finish
     */

    /**
     * Fired BEFORE the transition FROM the page starts.
     * Useful to deal with exit tasks (disallow user focus, animation optimisation,...).
     *
     * However it is not recommended to launch heavy processing at this
     * time not to hinder the transition's animation.
     *
     * @event exit-animation-start
     */

    /**
     * Fired AFTER the transition FROM the page finished.
     * Useful to handle exit tasks when your page isn't visible anymore
     * (reset scroller position,...).
     *
     * @event exit-animation-finish
     */

    properties: {
      /**
       * Flag set to `true` only if this page is the one selected.
       */
      selectedPage: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        readOnly: true
      },

      /**
       * Temporary reference to the original `animationConfig` of the page
       * whenever the behavior needs to change it.
       */
      _defaultAnimationConfig: {
        type: Object,
        value: {},
        readOnly: true
      },

      /**
       * Temporary reference to the original `sharedElements` of the page
       * whenever the behavior needs to change it.
       */
      _defaultSharedElements: {
        type: Object,
        value: {},
        readOnly: true
      },

      /**
       * Flag indicating if this page was initialized.
       */
      _neonPageBehaviorInitialized: {
        type: Boolean,
        value: false,
        readOnly: true
      }
    },

    attached: function() {
      if (this.parentElement.localName === 'neon-animated-pages') {
        // Initialize the handler
        this._boundIronSelectHandler = this._pageChanged.bind(this);
        this._boundNeonAnimationFinishedHandler = this._neonAnimationFinished.bind(this);
        this.parentElement.addEventListener('iron-select', this._boundIronSelectHandler);
        this.parentElement.addEventListener('neon-animation-finish', this._boundNeonAnimationFinishedHandler);
      }
    },

    detached: function() {
      if (this.parentElement.localName === 'neon-animated-pages') {
        this.parentElement.removeEventListener('iron-select', this._boundIronSelectHandler);
        this.parentElement.removeEventListener('neon-animation-finish', this._boundNeonAnimationFinishedHandler);
      }
    },

    /**
     * Method responsible for retrieving the `animationConfig` map
     * to be used when transitioning from/to the page `pageValue`.
     * By default, will get the property whose name is
     * `animationConfig + pageValue`. If such a property does not exist,
     * it will fall back on the `animationConfig` property.
     * (ie if `pageValue`='home-alone', the default implementation of this method
     * will return the `animationConfigHomeAlone` property if it is defined, and
     * `animationConfig` if not).
     * 
     * The page may override this method if necessary. If you do, the method
     * MUST return `this._defaultAnimationConfig` as the fallback.
     *
     * @method _getAnimationConfigForPage
     * @param {string} pageValue the value for the page to transition from/to
     * (as in neon-animated-pages.selected).
     * @return {object} the `animationConfig` to use for the transition
     * from/to the page `pageValue`
     */
    _getAnimationConfigForPage: function(pageValue) {
      var normalizedPageValue = this._normalizePageValue(pageValue);
      if (!normalizedPageValue) {
        return this._defaultAnimationConfig;
      }
      return this._getAttributeCaseInsensitive('animationConfig' + normalizedPageValue) || this._defaultAnimationConfig;
    },

    /**
     * Method responsible for retrieving the `sharedElements` map
     * to be used when transitioning from/to the page `pageValue`.
     * By default, will get the property whose name is
     * `sharedElements + pageValue + [Entry|Exit]` with 'Entry' or 'Exit' being optional.
     * If such a property does not exist, it will fall back
     * on the `sharedElements` property.
     * (ie if `pageValue`='home-alone' and entering this page from the page 'home-alone',
     * the default implementation of this method will return the `sharedElementsHomeAloneEntry`
     * property if it is defined, `sharedElementsHomeAlone` otherwise and `sharedElements` if none
     * of the 2 aforementioned properties are defined).
     * 
     * The page may override this method if necessary. If you do, the method
     * MUST return `this._defaultSharedElements` as the fallback.
     *
     * @method _getSharedElementsForPage
     * @param {string} pageValue the value for the page to transition from/to
     * (as in neon-animated-pages.selected).
     * @param {boolean} entry is `true` if this page is transitionning
     * from the page `pageValue`, `false` otherwise.
     * @return {object} the `sharedElements` to use for the transition
     * from or /to (depending on `entry`) the page `pageValue`
     */
    _getSharedElementsForPage: function(pageValue, entry) {
      var normalizedPageValue = this._normalizePageValue(pageValue);
      if (!normalizedPageValue) {
        return this._defaultSharedElements;
      }
      var propertyName = 'sharedElements' + normalizedPageValue;
      var propertyNameSuffix = entry ? 'Entry' : 'Exit';
      return this._getAttributeCaseInsensitive(propertyName + propertyNameSuffix) || this._getAttributeCaseInsensitive(propertyName) || this._defaultSharedElements;
    },

    /**
     * Get the value representing a page, as in `neon-animated-pages.selected`.
     */
    _getPageValue: function(page) {
      var value;
      if (page) {
        if (this.parentElement.attrForSelected) {
          value = this.parentElement._valueForItem(page);
        } else {
          value = this.parentElement.indexOf(page);
        }
      }
      return this._safeToString(value);
    },

    /**
     * Safely get a `String` from a `Number`or a `String`.
     */
    _safeToString: function(value) {
       return (value !== undefined && value !== null) ? value.toString() : undefined;
    },

    /**
     * Called when the displayed page is about to change. Fires 'start' events and
     * sets the `animationConfig` to be used according to the original and destination pages.
     */
    _pageChanged: function(event) {
      if (event && event.target === this.parentElement) {
        // transitionPageValue is the page we transition from or to.
        // Set to null we might get an undefined in case of the initial transition
        var transitionPageValue = null;
        var eventToFire;
        var thisPageValue = this._getPageValue(this);
        var lastPageValue = this._safeToString(this.parentElement._prevSelected);

        // Keep a reference to the original animation configuration of the page
        if (!this._neonPageBehaviorInitialized) {
          this._set_defaultAnimationConfig(this.animationConfig);
          this._set_defaultSharedElements(this.sharedElements);
        }

        if (this._safeToString(this.parentElement.selected) === thisPageValue) {
          // This is the new selected page, it must fire entry-animation-start
          this._setSelectedPage(true);
          eventToFire = 'entry-animation-start';
          transitionPageValue = lastPageValue;
          
          // Fire events for the very first page shown when animateInitialSelection is not set.
          // We use async to ensure that the 'start' event is fired before the 'finish' one.
          if (!this._neonPageBehaviorInitialized && !this.parentElement.animateInitialSelection) {
            this.async(function() {
              this._fireNeonPageEvent('entry-animation-finish', undefined, undefined, thisPageValue, this);
            }, 1);
          }
        } else if (this.selectedPage) {
          // This is the previously selected page, it must fire exit-animation-start
          this._setSelectedPage(false);
          eventToFire = 'exit-animation-start';
          transitionPageValue = this._safeToString(this.parentElement.selected);
        }

        // Flag the page as initialized
        this._set_neonPageBehaviorInitialized(true);

        // If transitioning to or from a page (undefined during the initial transition),
        // we must modify the animation configuration accordingly
        if (transitionPageValue || typeof transitionPageValue === 'undefined') {
          this.animationConfig = this._getAnimationConfigForPage(transitionPageValue);
          this.sharedElements = this._getSharedElementsForPage(transitionPageValue, this.selectedPage);
        }

        if (eventToFire) {
          // Effectively fire the ....-animation-start event with correct details
          this._fireNeonPageEvent(eventToFire,
            this.selectedPage ? transitionPageValue : thisPageValue,
            this.selectedPage ? transitionPageValue ? this.parentElement._valueToItem(transitionPageValue) : undefined : this,
            this.selectedPage ? thisPageValue : transitionPageValue,
            this.selectedPage ? this : transitionPageValue ? this.parentElement._valueToItem(transitionPageValue) : undefined);
        }
      }
    },

    /**
     * Called when the displayed page has been changed. Fires 'finish' events.
     */
    _neonAnimationFinished: function(event) {
      var eventToFire;
      if (event.detail.toPage === this) {
        eventToFire = 'entry-animation-finish';
      } else if (event.detail.fromPage === this) {
        eventToFire = 'exit-animation-finish';
      }
      if (eventToFire) {
        this._fireNeonPageEvent(eventToFire, this._getPageValue(event.detail.fromPage), event.detail.fromPage, this._getPageValue(event.detail.toPage), event.detail.toPage);
      }
    },

    /**
     */
    _fireNeonPageEvent: function(eventName, from, fromPage, to, toPage) {
      var eventDetails = {
        animationConfig: this.animationConfig,
        sharedElements: this.sharedElements,
        from: from === to ? undefined : from,
        fromPage: fromPage === toPage ? undefined : fromPage,
        to: to,
        toPage: toPage
      };
      this.fire(eventName, eventDetails, {bubbles: false});
    },

    /**
     * Normalize a string by removing all characters that are not
     * letters, numbers or underscores.
     */
    _normalizePageValue: function(value) {
      if (value) {
        return value.replace(/[^.0-9a-z_$]+/gi, '');
      }
      return '';
    },

    /**
     * Get an attribute from it's name, ignoring the case.
     */
    _getAttributeCaseInsensitive: function(attributeName) {
      var attr = (attributeName + '').toLowerCase();
      for (var a in this) {
        if (this.hasOwnProperty(a) && attr == (a + '').toLowerCase()) {
          return this[a];
        }
      }
      return undefined;
    }
</script>
